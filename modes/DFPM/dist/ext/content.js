/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 18);
/******/ })
/************************************************************************/
/******/ ({

/***/ 0:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["logger"] = logger;
//This file adds the ability to log window.screen access

function logger(self, emitter){
    if(self.screen){
        let proxy = new Proxy(self.screen, {
            get: function(target, propertyKey, receiver){
                emitter.emit('event', {
                    method: 'get',
                    path: `self.screen.${propertyKey}`,
                    level: 'info',
                    category: 'screen',
                })
                return Reflect.get(target, propertyKey, target)
            }
        });
        Reflect.defineProperty(self, 'screen', {
            get:function(){ return proxy },
            set:function(val){ /* meh */ },
        })
    }
}

const metadata = {
    category:"screen",
    icon:"fa-desktop",
    title:"Screen Properties",
    desc:"Screen resolution & color depth provide a few more bits of identifying information.",
    moreInfo:"https://browserleaks.com/javascript",
    priority:5,
}
/* harmony export (immutable) */ __webpack_exports__["metadata"] = metadata;


/***/ }),

/***/ 1:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = addJsonRpcListener;
/* harmony export (immutable) */ __webpack_exports__["b"] = callJsonRpc;
//Chrome extensions have an obnoxious amount of diff contexts
// * Content Page: can only use `chrome.runtime.sendMessage`
// * Background Page: Can use all methods. Needs to proxy messages from the devtools_page to content pages.
// * UI Pages: Can use all methods? (need to confirm chrome.tabs)
// * devtools_page: Does not have access to chrome.tabs so must proxy communication to content pages through background page. Can listen to messages not to a specific tab with `chrome.runtime.onMessage`.
// * devtools panel: Does not have access to chrome.tabs so must proxy communication to content pages through background page. Can listen to messages not to a specific tab with `chrome.runtime.onMessage`.

/**
 * Registers a method that is callable from other chrome extension contexts
 * @param {*} methodName the name of the method to register
 * @param {*} handler a function to be called when the method is called.
 *    Note: An additional argument, the senders tab id (or null if sender does not have tab id) will be will be appended to the arguments when calling the handler
 */
function addJsonRpcListener(methodName, handler) {
  chrome.runtime.onMessage.addListener(function(request, sender) {
    // Check if the call is for this listener
    if (request.method != methodName) {
      return;
    }

    var params = request.params || []
    params.push((sender.tab && sender.tab.id!=-1 && sender.tab.id) || null)
    var ret = handler.apply(null, params);
    if (!(ret || {}).then) {
      ret = Promise.resolve(ret);
    }
    ret.then(
      function(result) {
        if (sender.tab && sender.tab.id !== -1 && chrome.tabs) { //chrome.tabs is not defined in devtools && devtools sender.tab.id == -1
          chrome.tabs.sendMessage(sender.tab.id, { error: null, result: result, id: request.id });
        } else {
          chrome.runtime.sendMessage({ error: null, result: result, id: request.id });
        }
      },
      function(error) {
        if (sender.tab && sender.tab.id !== -1  && chrome.tabs) {
          chrome.tabs.sendMessage(sender.tab.id, { error: error, result: null, id: request.id });
        } else {
          chrome.runtime.sendMessage({ error: error, result: null, id: request.id });
        }
      }
    );
  });
}

/**
 * Calls a method in another chrome context that has been registered with addJsonRpcListener
 * @param {*} tabId the tab to send the message to. Pass null to send the message to a non tab recipient (aka background page)
 * @param {*} method the name of the method to call
 * @param {*} params arguments to pass to the method as additional params
 */
function callJsonRpc(tabId, method, params) {
  params = Array.from(arguments).splice(2)
  return new Promise(function(resolve, reject) {
    var id = Math.random();

    function cb(request) {
      if (request.id !== id) return; //its not us... ignore
      chrome.runtime.onMessage.removeListener(cb);
      if (request.error) { reject(request.error) } else { resolve(request.result) }
    }
    chrome.runtime.onMessage.addListener(cb)
    if (tabId) {
      chrome.tabs.sendMessage(tabId, { method: method, params: params, id: id });
    } else {
      chrome.runtime.sendMessage({ method: method, params: params, id: id });
    }
  });
}


/***/ }),

/***/ 18:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_raw_loader_dist_inject_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_raw_loader_dist_inject_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_raw_loader_dist_inject_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__messaging__ = __webpack_require__(1);




const eventDivId = Object(__WEBPACK_IMPORTED_MODULE_1__util__["b" /* guid */])()

function dispatchEvent(eventDivId, data){
    var div = document.getElementById(eventDivId);
    div.innerText = data
    var event = document.createEvent('Event');
    event.initEvent(eventDivId, true, true);
    div.dispatchEvent(event);
}

const script = [
    __WEBPACK_IMPORTED_MODULE_0_raw_loader_dist_inject_js___default.a,
    `dfpm.emitEvent = (${dispatchEvent.toString()}).bind(null, "${eventDivId}")`,
    'dfpm(self);',
].join('\n')

function evalScript(actualCode){
    var script = document.createElement('script');
    script.textContent = actualCode;
    (document.head||document.documentElement).appendChild(script);
    script.parentNode.removeChild(script);
}

function createEventDiv(eventDivId, callback){
    var div = document.createElement("div");
    div.style.display = "none"
    div.id = eventDivId
    document.getElementsByTagName('html')[0].appendChild(div)
    div.addEventListener(eventDivId, function(){
        var data = JSON.parse(div.textContent)
        callback(data)
    })
}

//inject the script, listen for events, and send events to background page when we get them
createEventDiv(eventDivId, function(evt){
    if(!evt.category) return; //ignore evts if they don't have a category
    Object(__WEBPACK_IMPORTED_MODULE_2__messaging__["b" /* callJsonRpc */])(null, "contentPageEvent", evt)
})
evalScript(script)


/***/ }),

/***/ 19:
/***/ (function(module, exports) {

module.exports = "window[\"dfpm\"] =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"logger\"] = logger;\n//This file adds the ability to log window.screen access\n\nfunction logger(self, emitter){\n    if(self.screen){\n        let proxy = new Proxy(self.screen, {\n            get: function(target, propertyKey, receiver){\n                emitter.emit('event', {\n                    method: 'get',\n                    path: `self.screen.${propertyKey}`,\n                    level: 'info',\n                    category: 'screen',\n                })\n                return Reflect.get(target, propertyKey, target)\n            }\n        });\n        Reflect.defineProperty(self, 'screen', {\n            get:function(){ return proxy },\n            set:function(val){ /* meh */ },\n        })\n    }\n}\n\nconst metadata = {\n    category:\"screen\",\n    icon:\"fa-desktop\",\n    title:\"Screen Properties\",\n    desc:\"Screen resolution & color depth provide a few more bits of identifying information.\",\n    moreInfo:\"https://browserleaks.com/javascript\",\n    priority:5,\n}\n/* harmony export (immutable) */ __webpack_exports__[\"metadata\"] = metadata;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"default\"] = dfpm;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_eventemitter2__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_eventemitter2___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_eventemitter2__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__loggers_navigator__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__loggers_canvas__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__loggers_webgl__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__loggers_screen__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__loggers_webrtc__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__loggers_audio__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__loggers_worker__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__loggers_font__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__loggers_battery__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__util__ = __webpack_require__(12);\n\n\n\n//import all the diff loggers\n\n\n\n\n\n\n\n\n\n\n\n\nconst loggers = [\n    __WEBPACK_IMPORTED_MODULE_1__loggers_navigator__,\n    __WEBPACK_IMPORTED_MODULE_2__loggers_canvas__,\n    __WEBPACK_IMPORTED_MODULE_3__loggers_webgl__,\n    __WEBPACK_IMPORTED_MODULE_4__loggers_screen__,\n    __WEBPACK_IMPORTED_MODULE_5__loggers_webrtc__,\n    __WEBPACK_IMPORTED_MODULE_6__loggers_audio__,\n    __WEBPACK_IMPORTED_MODULE_7__loggers_worker__,\n    __WEBPACK_IMPORTED_MODULE_8__loggers_font__,\n    __WEBPACK_IMPORTED_MODULE_9__loggers_battery__,\n]\n/* harmony export (immutable) */ __webpack_exports__[\"loggers\"] = loggers;\n\n\n//This script gets ran in every JS context BEFORE any other JS\nfunction dfpm(self){\n    //Check if we have ran before\n    if(self.dfpmId) return;\n\n    var dfpmId = Object(__WEBPACK_IMPORTED_MODULE_10__util__[\"b\" /* guid */])()\n    self.dfpmId = dfpmId\n\n    var logDedupe = {}\n    function log(event){\n        var msg = JSON.stringify(event)\n        if(logDedupe[msg]) return;\n        logDedupe[msg] = true;\n        if(typeof(event) == \"object\"){\n            event.jsContextId = dfpmId;\n            event.url = self.location && self.location.toString()\n            event.stack = Object(__WEBPACK_IMPORTED_MODULE_10__util__[\"a\" /* getStackTrace */])()\n        }\n        msg = JSON.stringify(event)\n        dfpm.emitEvent(msg)\n    }\n\n    var emitter = new __WEBPACK_IMPORTED_MODULE_0_eventemitter2__[\"EventEmitter2\"]({wildcard:true, newListener:false})\n    log(`info injecting...`)\n    loggers.forEach((logger)=>{\n        logger.logger(self, emitter)\n    })\n    emitter.on('*', log)\n\n    //--------------------------------------------------\n    //It is possible to create an iframe and then never run script in it (so our break point wont fire)\n    //Iframes give you a clean JS context so we dirty them up lazyly\n    //--------------------------------------------------\n    //util function to dfpm iframes created in this manner\n    var iframeCache = new WeakMap()\n    function inject(element) {\n        if(iframeCache.has(element)) return; //some sites hit this code constantly and it is CPU intensive\n        if (element.tagName.toUpperCase() === \"IFRAME\" && element.contentWindow) {\n            iframeCache.set(element, true)\n            try {\n                var hasAccess = element.contentWindow.HTMLCanvasElement;\n            } catch (e) { return /* nothing we can do */ }\n            dfpm(element.contentWindow);\n        }\n    }\n    //overrideDocumentProto so you can't get a clean iframe\n    function overrideDocumentProto(root) {\n        function doOverrideDocumentProto(old, name) {\n            //root.prototype[storedObjectPrefix + name] = old;\n            var value = function () {\n                var element = old.apply(this, arguments);\n                if (!element) return element;\n                var eleType = Object.prototype.toString.call(element)\n                if(eleType == \"[object HTMLCollection]\" || eleType == \"[object NodeList]\"){\n                    for (var i = 0; i < element.length; ++i) {\n                        var ele = element[i]\n                        if(Object.prototype.toString.call(ele)==\"[object HTMLIFrameElement]\") inject(ele);\n                    }\n                } else if (eleType == \"[object HTMLIFrameElement]\"){\n                    inject(element);\n                }\n                return element;\n            }\n            value.toString = old.toString.bind(old)\n            Object.defineProperty(root.prototype, name, { value });\n        }\n        doOverrideDocumentProto(root.prototype.createElement, \"createElement\");\n        doOverrideDocumentProto(root.prototype.createElementNS, \"createElementNS\");\n        doOverrideDocumentProto(root.prototype.getElementById, \"getElementById\");\n        doOverrideDocumentProto(root.prototype.getElementsByName, \"getElementsByName\");\n        doOverrideDocumentProto(root.prototype.getElementsByClassName, \"getElementsByClassName\");\n        doOverrideDocumentProto(root.prototype.getElementsByTagName, \"getElementsByTagName\");\n        doOverrideDocumentProto(root.prototype.getElementsByTagNameNS, \"getElementsByTagNameNS\");\n        doOverrideDocumentProto(root.prototype.querySelector, \"querySelector\");\n        doOverrideDocumentProto(root.prototype.querySelectorAll, \"querySelectorAll\");\n    }\n    self.Document && overrideDocumentProto(self.Document);\n\n}\ndfpm.emitEvent = console.log\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n * EventEmitter2\r\n * https://github.com/hij1nx/EventEmitter2\r\n *\r\n * Copyright (c) 2013 hij1nx\r\n * Licensed under the MIT license.\r\n */\r\n;!function(undefined) {\r\n\r\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\r\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\r\n  };\r\n  var defaultMaxListeners = 10;\r\n\r\n  function init() {\r\n    this._events = {};\r\n    if (this._conf) {\r\n      configure.call(this, this._conf);\r\n    }\r\n  }\r\n\r\n  function configure(conf) {\r\n    if (conf) {\r\n      this._conf = conf;\r\n\r\n      conf.delimiter && (this.delimiter = conf.delimiter);\r\n      this._maxListeners = conf.maxListeners !== undefined ? conf.maxListeners : defaultMaxListeners;\r\n\r\n      conf.wildcard && (this.wildcard = conf.wildcard);\r\n      conf.newListener && (this.newListener = conf.newListener);\r\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\r\n\r\n      if (this.wildcard) {\r\n        this.listenerTree = {};\r\n      }\r\n    } else {\r\n      this._maxListeners = defaultMaxListeners;\r\n    }\r\n  }\r\n\r\n  function logPossibleMemoryLeak(count, eventName) {\r\n    var errorMsg = '(node) warning: possible EventEmitter memory ' +\r\n        'leak detected. ' + count + ' listeners added. ' +\r\n        'Use emitter.setMaxListeners() to increase limit.';\r\n\r\n    if(this.verboseMemoryLeak){\r\n      errorMsg += ' Event name: ' + eventName + '.';\r\n    }\r\n\r\n    if(typeof process !== 'undefined' && process.emitWarning){\r\n      var e = new Error(errorMsg);\r\n      e.name = 'MaxListenersExceededWarning';\r\n      e.emitter = this;\r\n      e.count = count;\r\n      process.emitWarning(e);\r\n    } else {\r\n      console.error(errorMsg);\r\n\r\n      if (console.trace){\r\n        console.trace();\r\n      }\r\n    }\r\n  }\r\n\r\n  function EventEmitter(conf) {\r\n    this._events = {};\r\n    this.newListener = false;\r\n    this.verboseMemoryLeak = false;\r\n    configure.call(this, conf);\r\n  }\r\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\r\n\r\n  //\r\n  // Attention, function return type now is array, always !\r\n  // It has zero elements if no any matches found and one or more\r\n  // elements (leafs) if there are matches\r\n  //\r\n  function searchListenerTree(handlers, type, tree, i) {\r\n    if (!tree) {\r\n      return [];\r\n    }\r\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\r\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\r\n    if (i === typeLength && tree._listeners) {\r\n      //\r\n      // If at the end of the event(s) list and the tree has listeners\r\n      // invoke those listeners.\r\n      //\r\n      if (typeof tree._listeners === 'function') {\r\n        handlers && handlers.push(tree._listeners);\r\n        return [tree];\r\n      } else {\r\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\r\n          handlers && handlers.push(tree._listeners[leaf]);\r\n        }\r\n        return [tree];\r\n      }\r\n    }\r\n\r\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\r\n      //\r\n      // If the event emitted is '*' at this part\r\n      // or there is a concrete match at this patch\r\n      //\r\n      if (currentType === '*') {\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\r\n          }\r\n        }\r\n        return listeners;\r\n      } else if(currentType === '**') {\r\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\r\n        if(endReached && tree._listeners) {\r\n          // The next element has a _listeners, add it to the handlers.\r\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\r\n        }\r\n\r\n        for (branch in tree) {\r\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\r\n            if(branch === '*' || branch === '**') {\r\n              if(tree[branch]._listeners && !endReached) {\r\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\r\n              }\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            } else if(branch === nextType) {\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\r\n            } else {\r\n              // No match on this one, shift into the tree but not in the type array.\r\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\r\n            }\r\n          }\r\n        }\r\n        return listeners;\r\n      }\r\n\r\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\r\n    }\r\n\r\n    xTree = tree['*'];\r\n    if (xTree) {\r\n      //\r\n      // If the listener tree will allow any match for this part,\r\n      // then recursively explore all branches of the tree\r\n      //\r\n      searchListenerTree(handlers, type, xTree, i+1);\r\n    }\r\n\r\n    xxTree = tree['**'];\r\n    if(xxTree) {\r\n      if(i < typeLength) {\r\n        if(xxTree._listeners) {\r\n          // If we have a listener on a '**', it will catch all, so add its handler.\r\n          searchListenerTree(handlers, type, xxTree, typeLength);\r\n        }\r\n\r\n        // Build arrays of matching next branches and others.\r\n        for(branch in xxTree) {\r\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\r\n            if(branch === nextType) {\r\n              // We know the next element will match, so jump twice.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\r\n            } else if(branch === currentType) {\r\n              // Current node matches, move into the tree.\r\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\r\n            } else {\r\n              isolatedBranch = {};\r\n              isolatedBranch[branch] = xxTree[branch];\r\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\r\n            }\r\n          }\r\n        }\r\n      } else if(xxTree._listeners) {\r\n        // We have reached the end and still on a '**'\r\n        searchListenerTree(handlers, type, xxTree, typeLength);\r\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\r\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\r\n      }\r\n    }\r\n\r\n    return listeners;\r\n  }\r\n\r\n  function growListenerTree(type, listener) {\r\n\r\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n\r\n    //\r\n    // Looks for two consecutive '**', if so, don't add the event at all.\r\n    //\r\n    for(var i = 0, len = type.length; i+1 < len; i++) {\r\n      if(type[i] === '**' && type[i+1] === '**') {\r\n        return;\r\n      }\r\n    }\r\n\r\n    var tree = this.listenerTree;\r\n    var name = type.shift();\r\n\r\n    while (name !== undefined) {\r\n\r\n      if (!tree[name]) {\r\n        tree[name] = {};\r\n      }\r\n\r\n      tree = tree[name];\r\n\r\n      if (type.length === 0) {\r\n\r\n        if (!tree._listeners) {\r\n          tree._listeners = listener;\r\n        }\r\n        else {\r\n          if (typeof tree._listeners === 'function') {\r\n            tree._listeners = [tree._listeners];\r\n          }\r\n\r\n          tree._listeners.push(listener);\r\n\r\n          if (\r\n            !tree._listeners.warned &&\r\n            this._maxListeners > 0 &&\r\n            tree._listeners.length > this._maxListeners\r\n          ) {\r\n            tree._listeners.warned = true;\r\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      name = type.shift();\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // By default EventEmitters will print a warning if more than\r\n  // 10 listeners are added to it. This is a useful default which\r\n  // helps finding memory leaks.\r\n  //\r\n  // Obviously not all Emitters should be limited to 10. This function allows\r\n  // that to be increased. Set to zero for unlimited.\r\n\r\n  EventEmitter.prototype.delimiter = '.';\r\n\r\n  EventEmitter.prototype.setMaxListeners = function(n) {\r\n    if (n !== undefined) {\r\n      this._maxListeners = n;\r\n      if (!this._conf) this._conf = {};\r\n      this._conf.maxListeners = n;\r\n    }\r\n  };\r\n\r\n  EventEmitter.prototype.event = '';\r\n\r\n\r\n  EventEmitter.prototype.once = function(event, fn) {\r\n    return this._once(event, fn, false);\r\n  };\r\n\r\n  EventEmitter.prototype.prependOnceListener = function(event, fn) {\r\n    return this._once(event, fn, true);\r\n  };\r\n\r\n  EventEmitter.prototype._once = function(event, fn, prepend) {\r\n    this._many(event, 1, fn, prepend);\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.many = function(event, ttl, fn) {\r\n    return this._many(event, ttl, fn, false);\r\n  }\r\n\r\n  EventEmitter.prototype.prependMany = function(event, ttl, fn) {\r\n    return this._many(event, ttl, fn, true);\r\n  }\r\n\r\n  EventEmitter.prototype._many = function(event, ttl, fn, prepend) {\r\n    var self = this;\r\n\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('many only accepts instances of Function');\r\n    }\r\n\r\n    function listener() {\r\n      if (--ttl === 0) {\r\n        self.off(event, listener);\r\n      }\r\n      return fn.apply(this, arguments);\r\n    }\r\n\r\n    listener._origin = fn;\r\n\r\n    this._on(event, listener, prepend);\r\n\r\n    return self;\r\n  };\r\n\r\n  EventEmitter.prototype.emit = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this.newListener) {\r\n      if (!this._events.newListener) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    var al = arguments.length;\r\n    var args,l,i,j;\r\n    var handler;\r\n\r\n    if (this._all && this._all.length) {\r\n      handler = this._all.slice();\r\n      if (al > 3) {\r\n        args = new Array(al);\r\n        for (j = 0; j < al; j++) args[j] = arguments[j];\r\n      }\r\n\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler[i].call(this, type);\r\n          break;\r\n        case 2:\r\n          handler[i].call(this, type, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler[i].call(this, type, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          handler[i].apply(this, args);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    } else {\r\n      handler = this._events[type];\r\n      if (typeof handler === 'function') {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler.call(this);\r\n          break;\r\n        case 2:\r\n          handler.call(this, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler.call(this, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          args = new Array(al - 1);\r\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n          handler.apply(this, args);\r\n        }\r\n        return true;\r\n      } else if (handler) {\r\n        // need to make copy of handlers because list can change in the middle\r\n        // of emit call\r\n        handler = handler.slice();\r\n      }\r\n    }\r\n\r\n    if (handler && handler.length) {\r\n      if (al > 3) {\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n      }\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          handler[i].call(this);\r\n          break;\r\n        case 2:\r\n          handler[i].call(this, arguments[1]);\r\n          break;\r\n        case 3:\r\n          handler[i].call(this, arguments[1], arguments[2]);\r\n          break;\r\n        default:\r\n          handler[i].apply(this, args);\r\n        }\r\n      }\r\n      return true;\r\n    } else if (!this._all && type === 'error') {\r\n      if (arguments[1] instanceof Error) {\r\n        throw arguments[1]; // Unhandled 'error' event\r\n      } else {\r\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\r\n      }\r\n      return false;\r\n    }\r\n\r\n    return !!this._all;\r\n  };\r\n\r\n  EventEmitter.prototype.emitAsync = function() {\r\n\r\n    this._events || init.call(this);\r\n\r\n    var type = arguments[0];\r\n\r\n    if (type === 'newListener' && !this.newListener) {\r\n        if (!this._events.newListener) { return Promise.resolve([false]); }\r\n    }\r\n\r\n    var promises= [];\r\n\r\n    var al = arguments.length;\r\n    var args,l,i,j;\r\n    var handler;\r\n\r\n    if (this._all) {\r\n      if (al > 3) {\r\n        args = new Array(al);\r\n        for (j = 1; j < al; j++) args[j] = arguments[j];\r\n      }\r\n      for (i = 0, l = this._all.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          promises.push(this._all[i].call(this, type));\r\n          break;\r\n        case 2:\r\n          promises.push(this._all[i].call(this, type, arguments[1]));\r\n          break;\r\n        case 3:\r\n          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\r\n          break;\r\n        default:\r\n          promises.push(this._all[i].apply(this, args));\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      handler = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\r\n    } else {\r\n      handler = this._events[type];\r\n    }\r\n\r\n    if (typeof handler === 'function') {\r\n      this.event = type;\r\n      switch (al) {\r\n      case 1:\r\n        promises.push(handler.call(this));\r\n        break;\r\n      case 2:\r\n        promises.push(handler.call(this, arguments[1]));\r\n        break;\r\n      case 3:\r\n        promises.push(handler.call(this, arguments[1], arguments[2]));\r\n        break;\r\n      default:\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n        promises.push(handler.apply(this, args));\r\n      }\r\n    } else if (handler && handler.length) {\r\n      handler = handler.slice();\r\n      if (al > 3) {\r\n        args = new Array(al - 1);\r\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\r\n      }\r\n      for (i = 0, l = handler.length; i < l; i++) {\r\n        this.event = type;\r\n        switch (al) {\r\n        case 1:\r\n          promises.push(handler[i].call(this));\r\n          break;\r\n        case 2:\r\n          promises.push(handler[i].call(this, arguments[1]));\r\n          break;\r\n        case 3:\r\n          promises.push(handler[i].call(this, arguments[1], arguments[2]));\r\n          break;\r\n        default:\r\n          promises.push(handler[i].apply(this, args));\r\n        }\r\n      }\r\n    } else if (!this._all && type === 'error') {\r\n      if (arguments[1] instanceof Error) {\r\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\r\n      } else {\r\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\r\n      }\r\n    }\r\n\r\n    return Promise.all(promises);\r\n  };\r\n\r\n  EventEmitter.prototype.on = function(type, listener) {\r\n    return this._on(type, listener, false);\r\n  };\r\n\r\n  EventEmitter.prototype.prependListener = function(type, listener) {\r\n    return this._on(type, listener, true);\r\n  };\r\n\r\n  EventEmitter.prototype.onAny = function(fn) {\r\n    return this._onAny(fn, false);\r\n  };\r\n\r\n  EventEmitter.prototype.prependAny = function(fn) {\r\n    return this._onAny(fn, true);\r\n  };\r\n\r\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\r\n\r\n  EventEmitter.prototype._onAny = function(fn, prepend){\r\n    if (typeof fn !== 'function') {\r\n      throw new Error('onAny only accepts instances of Function');\r\n    }\r\n\r\n    if (!this._all) {\r\n      this._all = [];\r\n    }\r\n\r\n    // Add the function to the event listener collection.\r\n    if(prepend){\r\n      this._all.unshift(fn);\r\n    }else{\r\n      this._all.push(fn);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  EventEmitter.prototype._on = function(type, listener, prepend) {\r\n    if (typeof type === 'function') {\r\n      this._onAny(type, listener);\r\n      return this;\r\n    }\r\n\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('on only accepts instances of Function');\r\n    }\r\n    this._events || init.call(this);\r\n\r\n    // To avoid recursion in the case that type == \"newListeners\"! Before\r\n    // adding it to the listeners, first emit \"newListeners\".\r\n    this.emit('newListener', type, listener);\r\n\r\n    if (this.wildcard) {\r\n      growListenerTree.call(this, type, listener);\r\n      return this;\r\n    }\r\n\r\n    if (!this._events[type]) {\r\n      // Optimize the case of one listener. Don't need the extra array object.\r\n      this._events[type] = listener;\r\n    }\r\n    else {\r\n      if (typeof this._events[type] === 'function') {\r\n        // Change to array.\r\n        this._events[type] = [this._events[type]];\r\n      }\r\n\r\n      // If we've already got an array, just add\r\n      if(prepend){\r\n        this._events[type].unshift(listener);\r\n      }else{\r\n        this._events[type].push(listener);\r\n      }\r\n\r\n      // Check for listener leak\r\n      if (\r\n        !this._events[type].warned &&\r\n        this._maxListeners > 0 &&\r\n        this._events[type].length > this._maxListeners\r\n      ) {\r\n        this._events[type].warned = true;\r\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  EventEmitter.prototype.off = function(type, listener) {\r\n    if (typeof listener !== 'function') {\r\n      throw new Error('removeListener only takes instances of Function');\r\n    }\r\n\r\n    var handlers,leafs=[];\r\n\r\n    if(this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n    }\r\n    else {\r\n      // does not use listeners(), so no side effect of creating _events[type]\r\n      if (!this._events[type]) return this;\r\n      handlers = this._events[type];\r\n      leafs.push({_listeners:handlers});\r\n    }\r\n\r\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n      var leaf = leafs[iLeaf];\r\n      handlers = leaf._listeners;\r\n      if (isArray(handlers)) {\r\n\r\n        var position = -1;\r\n\r\n        for (var i = 0, length = handlers.length; i < length; i++) {\r\n          if (handlers[i] === listener ||\r\n            (handlers[i].listener && handlers[i].listener === listener) ||\r\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\r\n            position = i;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (position < 0) {\r\n          continue;\r\n        }\r\n\r\n        if(this.wildcard) {\r\n          leaf._listeners.splice(position, 1);\r\n        }\r\n        else {\r\n          this._events[type].splice(position, 1);\r\n        }\r\n\r\n        if (handlers.length === 0) {\r\n          if(this.wildcard) {\r\n            delete leaf._listeners;\r\n          }\r\n          else {\r\n            delete this._events[type];\r\n          }\r\n        }\r\n\r\n        this.emit(\"removeListener\", type, listener);\r\n\r\n        return this;\r\n      }\r\n      else if (handlers === listener ||\r\n        (handlers.listener && handlers.listener === listener) ||\r\n        (handlers._origin && handlers._origin === listener)) {\r\n        if(this.wildcard) {\r\n          delete leaf._listeners;\r\n        }\r\n        else {\r\n          delete this._events[type];\r\n        }\r\n\r\n        this.emit(\"removeListener\", type, listener);\r\n      }\r\n    }\r\n\r\n    function recursivelyGarbageCollect(root) {\r\n      if (root === undefined) {\r\n        return;\r\n      }\r\n      var keys = Object.keys(root);\r\n      for (var i in keys) {\r\n        var key = keys[i];\r\n        var obj = root[key];\r\n        if ((obj instanceof Function) || (typeof obj !== \"object\") || (obj === null))\r\n          continue;\r\n        if (Object.keys(obj).length > 0) {\r\n          recursivelyGarbageCollect(root[key]);\r\n        }\r\n        if (Object.keys(obj).length === 0) {\r\n          delete root[key];\r\n        }\r\n      }\r\n    }\r\n    recursivelyGarbageCollect(this.listenerTree);\r\n\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.offAny = function(fn) {\r\n    var i = 0, l = 0, fns;\r\n    if (fn && this._all && this._all.length > 0) {\r\n      fns = this._all;\r\n      for(i = 0, l = fns.length; i < l; i++) {\r\n        if(fn === fns[i]) {\r\n          fns.splice(i, 1);\r\n          this.emit(\"removeListenerAny\", fn);\r\n          return this;\r\n        }\r\n      }\r\n    } else {\r\n      fns = this._all;\r\n      for(i = 0, l = fns.length; i < l; i++)\r\n        this.emit(\"removeListenerAny\", fns[i]);\r\n      this._all = [];\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\r\n\r\n  EventEmitter.prototype.removeAllListeners = function(type) {\r\n    if (arguments.length === 0) {\r\n      !this._events || init.call(this);\r\n      return this;\r\n    }\r\n\r\n    if (this.wildcard) {\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\r\n\r\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\r\n        var leaf = leafs[iLeaf];\r\n        leaf._listeners = null;\r\n      }\r\n    }\r\n    else if (this._events) {\r\n      this._events[type] = null;\r\n    }\r\n    return this;\r\n  };\r\n\r\n  EventEmitter.prototype.listeners = function(type) {\r\n    if (this.wildcard) {\r\n      var handlers = [];\r\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\r\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\r\n      return handlers;\r\n    }\r\n\r\n    this._events || init.call(this);\r\n\r\n    if (!this._events[type]) this._events[type] = [];\r\n    if (!isArray(this._events[type])) {\r\n      this._events[type] = [this._events[type]];\r\n    }\r\n    return this._events[type];\r\n  };\r\n\r\n  EventEmitter.prototype.eventNames = function(){\r\n    return Object.keys(this._events);\r\n  }\r\n\r\n  EventEmitter.prototype.listenerCount = function(type) {\r\n    return this.listeners(type).length;\r\n  };\r\n\r\n  EventEmitter.prototype.listenersAny = function() {\r\n\r\n    if(this._all) {\r\n      return this._all;\r\n    }\r\n    else {\r\n      return [];\r\n    }\r\n\r\n  };\r\n\r\n  if (true) {\r\n     // AMD. Register as an anonymous module.\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\r\n      return EventEmitter;\r\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n  } else if (typeof exports === 'object') {\r\n    // CommonJS\r\n    module.exports = EventEmitter;\r\n  }\r\n  else {\r\n    // Browser global.\r\n    window.EventEmitter2 = EventEmitter;\r\n  }\r\n}();\r\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"logger\"] = logger;\n//This file adds the ability to log navigator access\n\nfunction logger(self, emitter){\n    if(self.navigator){\n        var origNavigator = self.navigator\n        let proxy = new Proxy(self.navigator, {\n            get: function(target, propertyKey, receiver){\n                emitter.emit('event', {\n                    method: 'get',\n                    path: `self.navigator.${propertyKey}`,\n                    level: 'info',\n                    category: 'navigator',\n                })\n                var ret = origNavigator[propertyKey]\n                if(typeof(ret)=='function'){\n                    ret = ret.bind(origNavigator)\n                }\n                return ret;\n            },\n        });\n        if(self.clientInformation){\n            Reflect.defineProperty(self, 'clientInformation', {\n                get:function(){ return proxy },\n                set:function(val){ /* meh */ },\n            })\n        }\n        Reflect.defineProperty(self, 'navigator', {\n            get:function(){ return proxy },\n            set:function(val){ /* meh */ },\n        })\n    }\n\n    if(self.navigator.connection){\n        var origConn = self.navigator.connection\n        let proxyConn = new Proxy(self.navigator.connection, {\n            get: function(target, propertyKey, receiver){\n                emitter.emit('event', {\n                    method: 'get',\n                    path: `self.navigator.connection.${propertyKey}`,\n                    level: 'info',\n                    category: 'navigator',\n                })\n                var ret = origConn[propertyKey]\n                if(typeof(ret)=='function'){\n                    ret = ret.bind(origConn)\n                }\n                return ret;\n            }\n        })\n        Reflect.defineProperty(self.navigator, 'connection', {\n            get:function(){ return proxyConn },\n            set:function(val){ /* meh */ },\n        })\n    }\n}\n\nconst metadata = {\n    category:\"navigator\",\n    icon:\"fa-font\",\n    title:\"Navigator Object\",\n    desc:\"The JavaScript navigator object is used for browser detection, connection information, plugins, etc.\",\n    moreInfo:\"https://browserleaks.com/javascript\",\n    priority:10,\n}\n/* harmony export (immutable) */ __webpack_exports__[\"metadata\"] = metadata;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"logger\"] = logger;\n//This file adds the ability to log canvas access & fingerprinting\n\n//XXX: log all canvas method calls\n\nfunction logger(self, emitter){\n\n    function emit(event){\n        event = Object.assign({\n            method: 'apply',\n            level: 'warning',\n            category: 'canvas',\n        }, event)\n        emitter.emit(event.level, event);\n    }\n\n    if(self.CanvasRenderingContext2D){\n        self.CanvasRenderingContext2D.prototype.fillText = new Proxy(self.CanvasRenderingContext2D.prototype.fillText, {\n            apply:function(target, thisArgument, args){\n                emit({path: 'self.CanvasRenderingContext2D.prototype.fillText'})\n                return Reflect.apply(target, thisArgument, args)\n            }\n        })\n        self.CanvasRenderingContext2D.prototype.strokeText = new Proxy(self.CanvasRenderingContext2D.prototype.strokeText, {\n            apply:function(target, thisArgument, args){\n                emit({path: 'self.CanvasRenderingContext2D.prototype.strokeText'})\n                return Reflect.apply(target, thisArgument, args)\n            }\n        })\n        self.CanvasRenderingContext2D.prototype.getImageData = new Proxy(self.CanvasRenderingContext2D.prototype.getImageData, {\n            apply:function(target, thisArgument, args){\n                emit({path: 'self.CanvasRenderingContext2D.prototype.getImageData'})\n                return Reflect.apply(target, thisArgument, args)\n            }\n        })\n    }\n    if(self.HTMLCanvasElement){\n        self.HTMLCanvasElement.prototype.toBlob = new Proxy(self.HTMLCanvasElement.prototype.toBlob, {\n            apply:function(target, thisArgument, args){\n                emit({path: 'self.HTMLCanvasElement.prototype.toBlob', level:'danger'})\n                return Reflect.apply(target, thisArgument, args)\n            }\n        })\n        self.HTMLCanvasElement.prototype.toDataURL = new Proxy(self.HTMLCanvasElement.prototype.toDataURL, {\n            apply:function(target, thisArgument, args){\n                emit({path: 'self.HTMLCanvasElement.prototype.toDataURL', level:'danger'})\n                return Reflect.apply(target, thisArgument, args)\n            }\n        })\n    }\n\n}\n\nconst metadata = {\n    category:\"canvas\",\n    icon:\"fa-paint-brush\",\n    title:\"Canvas Fingerprinting\",\n    desc:\"Draws a hidden image which varies depending on OS and hardware.\",\n    moreInfo:\"https://browserleaks.com/canvas\",\n    priority:1,\n}\n/* harmony export (immutable) */ __webpack_exports__[\"metadata\"] = metadata;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"logger\"] = logger;\n//This file adds the ability to log webgl access & fingerprinting\n\n//XXX: toDataUrl is used for both canvas and webgl... is there a way to figure out which one we are using\n//XXX: break out getExtension to include passed params\n\nfunction logger(self, emitter){\n\n    function logFunctionCall(fnName, proto, path){\n        var fn = proto[fnName]\n        proto[fnName] = new Proxy(fn, {\n            apply:function(target, thisArgument, args){\n                emitter.emit('event', {\n                    method: 'apply',\n                    level:({\n                        readPixels:'danger',\n                    })[fnName]||'warning',\n                    category:'webgl',\n                    path: path\n                })\n                return Reflect.apply(target, thisArgument, args)\n            }\n        })\n    }\n\n    if(self.WebGL2RenderingContext){\n        let reverseParamDict = {}\n        Reflect.ownKeys(self.WebGL2RenderingContext.prototype).forEach((key)=>{\n            if(typeof(key)===\"symbol\") return; //ignore symbols\n            if(key===\"getParameter\") return; //implemented below for better logging\n            if(key===\"getExtension\") return; //implemented below for better logging\n            try{\n                var val = self.WebGL2RenderingContext.prototype[key]\n                var type = typeof(val)\n            } catch(err){ return; }\n            if(type===\"function\")\n                logFunctionCall(key, self.WebGL2RenderingContext.prototype, 'self.WebGL2RenderingContext.prototype.'+key)\n            else if(type===\"number\")\n                reverseParamDict[val] = key\n        })\n        self.WebGL2RenderingContext.prototype.getParameter = new Proxy(self.WebGL2RenderingContext.prototype.getParameter, {\n            apply:function(target, thisArgument, args){\n                emitter.emit('event', {\n                    method: 'apply',\n                    level:'warning',\n                    category:'webgl',\n                    path: `self.WebGL2RenderingContext.prototype.getParameter(${reverseParamDict[args[0]]||args[0]})`\n                })\n                return Reflect.apply(target, thisArgument, args)\n            }\n        })\n        self.WebGL2RenderingContext.prototype.getExtension = new Proxy(self.WebGL2RenderingContext.prototype.getExtension, {\n            apply:function(target, thisArgument, args){\n                var level = \"info\"\n                if(args[0]==\"WEBGL_debug_renderer_info\") level=\"danger\";\n                emitter.emit('event', {\n                    method: 'apply',\n                    level:level,\n                    category:'webgl',\n                    path: `self.WebGL2RenderingContext.prototype.getExtension(${args[0]})`\n                })\n                return Reflect.apply(target, thisArgument, args)\n            }\n        })\n    }\n    if(self.WebGLRenderingContext){\n        let reverseParamDict = {}\n        Reflect.ownKeys(self.WebGLRenderingContext.prototype).forEach((key)=>{\n            if(typeof(key)===\"symbol\") return; //ignore symbols\n            if(key===\"getParameter\") return; //implemented below for better logging\n            if(key===\"getExtension\") return; //implemented below for better logging\n            try{\n                var val = self.WebGLRenderingContext.prototype[key]\n                var type = typeof(val)\n            } catch(err){ return; }\n            if(type===\"function\")\n                logFunctionCall(key, self.WebGLRenderingContext.prototype, 'self.WebGLRenderingContext.prototype.'+key)\n            else if(type===\"number\")\n                reverseParamDict[val] = key\n        })\n        self.WebGLRenderingContext.prototype.getParameter = new Proxy(self.WebGLRenderingContext.prototype.getParameter, {\n            apply:function(target, thisArgument, args){\n                emitter.emit('event', {\n                    method: 'apply',\n                    level:'warning',\n                    category:'webgl',\n                    path: `self.WebGLRenderingContext.prototype.getParameter(${reverseParamDict[args[0]]||args[0]})`\n                })\n                return Reflect.apply(target, thisArgument, args)\n            }\n        })\n        self.WebGLRenderingContext.prototype.getExtension = new Proxy(self.WebGLRenderingContext.prototype.getExtension, {\n            apply:function(target, thisArgument, args){\n                var level = \"info\"\n                if(args[0]==\"WEBGL_debug_renderer_info\") level=\"danger\";\n                emitter.emit('event', {\n                    method: 'apply',\n                    level:level,\n                    category:'webgl',\n                    path: `self.WebGLRenderingContext.prototype.getExtension(${args[0]})`\n                })\n                return Reflect.apply(target, thisArgument, args)\n            }\n        })\n    }\n\n}\n\nconst metadata = {\n    category:\"webgl\",\n    icon:\"fa-globe\",\n    title:\"WebGL Fingerprinting\",\n    desc:\"Draws a hidden image which varies depending on OS and hardware.\",\n    moreInfo:\"https://browserleaks.com/webgl\",\n    priority:1,\n}\n/* harmony export (immutable) */ __webpack_exports__[\"metadata\"] = metadata;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"logger\"] = logger;\n//This file adds the ability to log webrtc which can get your local ip :(\n\nfunction logger(self, emitter){\n\n    function logFunctionCall(fnName, proto, path){\n        var fn = proto[fnName]\n        proto[fnName] = new Proxy(fn, {\n            apply:function(target, thisArgument, args){\n                emitter.emit('event', {\n                    method: 'apply',\n                    level:({\n                        enumerateDevices:'danger',\n                        getSupportedConstraints:'danger',\n                    })[fnName]||'warning',\n                    category:'webrtc',\n                    path: path\n                })\n                return Reflect.apply(target, thisArgument, args)\n            }\n        })\n    }\n\n    if(self.MediaDevices){\n        Reflect.ownKeys(self.MediaDevices.prototype).forEach((key)=>{\n            if(typeof(key)===\"symbol\") return; //ignore symbols\n            try{\n                var val = self.MediaDevices.prototype[key]\n                var type = typeof(val)\n            } catch(err){ return; }\n            if(type===\"function\")\n                logFunctionCall(key, self.MediaDevices.prototype, 'self.MediaDevices.prototype.'+key)\n        })\n    }\n\n    if(self.RTCPeerConnection){\n        //override constructor\n        self.RTCPeerConnection = new Proxy(self.RTCPeerConnection, {\n            construct:function(target, argumentsList, newTarget){\n                emitter.emit('event', {\n                    method:'construct',\n                    level:'danger',\n                    category:'webrtc',\n                    path: 'self.RTCPeerConnection'\n                })\n                var ret = Reflect.construct(target, argumentsList, newTarget)\n                //onicecandidate is danger per https://github.com/diafygi/webrtc-ips/blob/master/index.html\n                var value = null\n                Object.defineProperty(ret, 'onicecandidate', {\n                    get: function(){\n                        emitter.emit('event', { method:'set', level:'danger', category:'webrtc', path: 'self.RTCPeerConnection.onicecandidate' })\n                        return value;\n                    },\n                    set:function(val){\n                        emitter.emit('event', { method:'get', level:'danger', category:'webrtc', path: 'self.RTCPeerConnection.onicecandidate' })\n                        value = val\n                    }\n                })\n                return ret;\n            }\n        })\n        //override method prototypes\n        Reflect.ownKeys(self.RTCPeerConnection.prototype).forEach((key)=>{\n            if(typeof(key)===\"symbol\") return; //ignore symbols\n            try{\n                var val = self.RTCPeerConnection.prototype[key]\n                var type = typeof(val)\n            } catch(err){ return; }\n            if(type===\"function\")\n                logFunctionCall(key, self.RTCPeerConnection.prototype, 'self.RTCPeerConnection.prototype.'+key)\n        })\n    }\n\n    if(navigator.getUserMedia){\n        navigator.getUserMedia = new Proxy(navigator.getUserMedia, {\n            apply:function(target, thisArgument, args){\n                emitter.emit('event', {\n                    method:'apply',\n                    level:'warning',\n                    category:'webrtc',\n                    path:'navigator.getUserMedia'\n                })\n                return Reflect.apply(target, thisArgument, args)\n            }\n        })\n    }\n\n}\n\nconst metadata = {\n    category:\"webrtc\",\n    icon:\"fa-video-camera\",\n    title:\"WebRTC Fingerprinting\",\n    desc:\"Can get your local ip address and information about attached webcams & microphones.\",\n    moreInfo:\"https://browserleaks.com/webrtc\",\n    priority:1,\n}\n/* harmony export (immutable) */ __webpack_exports__[\"metadata\"] = metadata;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"logger\"] = logger;\n//This file adds the ability to log audio fingerprinting\n//Tested on https://audiofingerprint.openwpm.com/\n\nfunction logger(self, emitter){\n\n    if(self.AudioContext){\n        self.AudioContext = new Proxy(self.AudioContext, {\n            construct:function(target, argumentsList, newTarget){\n                emitter.emit('event', {\n                    method:'construct',\n                    level:'danger',\n                    category:'audio',\n                    path:'self.AudioContext'\n                })\n                var ret = Reflect.construct(target, argumentsList, newTarget)\n                return new Proxy(ret, {\n                    get: function(target, propertyKey, receiver){\n                        emitter.emit('event', {\n                            method:'get',\n                            level:'info',\n                            category:'audio',\n                            path:'self.AudioContext.'+propertyKey.toString()\n                        })\n                        var value = ret[propertyKey];\n                        if(typeof(value) === \"function\")\n                            return value.bind(ret)\n                        return value\n                    }\n                })\n            }\n        })\n\n    }\n}\n\nconst metadata = {\n    category:\"audio\",\n    icon:\"fa-headphones\",\n    title:\"Audio Fingerprint\",\n    desc:\"An audio fingerprint is a property of your machine's audio stack.\",\n    moreInfo:\"https://audiofingerprint.openwpm.com/\",\n    priority:1,\n}\n/* harmony export (immutable) */ __webpack_exports__[\"metadata\"] = metadata;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"logger\"] = logger;\n//Logs if web workers or service workers are used. Not really an issue for fingerprinting but\n// gives you a non window JS contex which might avoid other dfpm depending on hook used to run dfpm\n\nfunction logger(self, emitter){\n\n    function emit(event){\n        event = Object.assign({\n            method: 'apply',\n            level: 'info',\n            category: 'worker',\n        }, event)\n        emitter.emit(event.level, event);\n    }\n\n    if(self.ServiceWorkerContainer){\n        ServiceWorkerContainer.prototype.register = new Proxy(self.ServiceWorkerContainer.prototype.register, {\n            apply:function(target, thisArgument, args){\n                emit({path: 'self.ServiceWorkerContainer.prototype.register'})\n                return Reflect.apply(target, thisArgument, args)\n            }\n        })\n    }\n\n    if(self.Worker){\n        self.Worker =  new Proxy(self.Worker, {\n            construct:function(target, argumentsList, newTarget){\n                emit({path:'self.Worker', method:'construct'})\n                return Reflect.construct(target, argumentsList, newTarget)\n            }\n        })\n    }\n}\n\nconst metadata = {\n    category:\"worker\",\n    icon:\"fa-cog\",\n    title:\"Worker APIs\",\n    desc:\"Can be used to work around fingerprint blockers.\",\n    moreInfo:\"https://aarontgrogg.com/blog/2015/07/20/the-difference-between-service-workers-web-workers-and-websockets/\",\n    priority:100,\n}\n/* harmony export (immutable) */ __webpack_exports__[\"metadata\"] = metadata;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"logger\"] = logger;\n// This file adds the ability to log font fingerprinting\n// This is def not 100% and can easy be worked around\n// Tested on a few diff fingerprint lib https://browserleaks.com/fonts\n\nfunction logger(self, emitter){\n    var desc = Reflect.getOwnPropertyDescriptor(HTMLElement.prototype, 'offsetWidth')\n    var origGet = desc.get\n    var fonts = new Set()\n    desc.get = function(){\n        var font = this.style.fontFamily\n        if(font){\n            fonts.add(font)\n            var level;\n            if(fonts.size < 5) return\n            else if(fonts.size < 10) level = 'warning'\n            else level = 'danger'\n            emitter.emit('event', {\n                method: 'get',\n                path: 'HTMLElement.prototype.offsetWidth',\n                level: level,\n                category: 'font',\n                font: font,\n            })\n        }\n        return origGet.call(this)\n    }\n    Reflect.defineProperty(HTMLElement.prototype, 'offsetWidth', desc)\n}\n\nconst metadata = {\n    category:\"font\",\n    icon:\"fa-font\",\n    title:\"Font Fingerprinting\",\n    desc:\"What fonts you have, and how they are drawn.\",\n    moreInfo:\"https://browserleaks.com/fonts\",\n    priority:1,\n}\n/* harmony export (immutable) */ __webpack_exports__[\"metadata\"] = metadata;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"logger\"] = logger;\n/**\n * Instruments the window.navigator.getBattery & window.BatteryManager.\n * In general this logger assumes checking the charging state is ok and checking any other state is fingerprinting\n * @param {Object} self the global JavaScript object. For example the browser's window object or the webworker's self object\n * @param {EventEmitter} emitter an event emitter that should be used to emit fingerprinting attempts.\n */\nfunction logger(self, emitter) {\n\n    /**\n     * Emits a a fingerprinting event so it will be shown in the DFPM extension and CLI\n     * @param {string} path the path you would use to access the property/method from the global object.\n     *              For example `self.navigator` or `self.WebGL2RenderingContext.prototype.drawElements` (instance method)\n     * @param {string} method the Reflect method which most closely describes the operation being logged.\n     *              See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect\n     *              You probably wont 'get' or 'apply' depending on if it is a property or method respectively\n     * @param {string} level an indication of how important/dangerous the fingerprinting event is. There are 3 levels:\n     *              \"info\": non critical or particularly worrisome\n     *              \"warning\": you might have been fingerprinted\n     *              \"danger\": you have for sure been fingerprinted!\n     */\n    function emitEvent(path, method, level){\n        emitter.emit('event', {\n            method: method,\n            path: path,\n            level: level,\n            category: metadata.category,\n        })\n    }\n\n    if(self.navigator && self.navigator.getBattery){\n        var fn = self.navigator.getBattery;\n        self.navigator.getBattery = new Proxy(fn, {\n            apply:function(target, thisArgument, args){\n                emitEvent(`self.navigator.getBattery`, 'apply', 'info')\n                return Reflect.apply(target, thisArgument, args).then(function(battery){\n                    return new Proxy(battery, {\n                        get: function(target, propertyKey, receiver){\n                            var level = ({\n                                'charging':'info',\n                                'removeEventListener':'info',\n                                'then':'none',\n                                'addEventListener':'none',\n                            })[propertyKey] || 'warning'\n                            if(level != 'none'){\n                                emitEvent('self.navigator.getBattery.'+propertyKey, 'get', level)\n                            }\n                            var ret = battery[propertyKey]\n                            if(typeof(ret)=='function'){\n                                ret = ret.bind(battery)\n                            }\n                            return ret;\n                        }\n                    })\n                })\n            }\n        })\n    }\n\n    if(self.navigator && self.BatteryManager){\n        var fn = self.BatteryManager.prototype.addEventListener;\n        self.BatteryManager.prototype.addEventListener = new Proxy(fn, {\n            apply:function(target, thisArgument, args){\n                emitEvent(`self.BatteryManager.prototype.addEventListener(\"${args[0]}\")`, 'apply',\n                    (args[0]+'').toLowerCase()=='chargingchange'?'info':'warning')\n                return Reflect.apply(target, thisArgument, args)\n            }\n        })\n    }\n}\n\n/**\n * The metadata object controls how your logger will be displayed inf the DFPM extension and command line tool\n * @property {string} category the category for your logger used to group your events. Should be unique to your logging module.\n * @property {string} icon the font awesome icon associated with your logger. Choose one from http://fontawesome.io/icons/\n * @property {string} title a short title for the fingerprinting detected by your logger\n * @property {string} desc A short description of the fingerprinting detected by your logger\n * @property {string} moreInfo A url with a full description of your logger's fingerprinting technique\n * @property {number} priority Used to sort loggers in the left hand panel of the DFPM extension\n */\nconst metadata = {\n    category: \"battery\",\n    icon: \"fa-battery-half\",\n    title: \"Battery Status\",\n    desc: \"The battery status object can be used as a short term identifier across domains.\",\n    moreInfo: \"https://blog.lukaszolejnik.com/battery-status-readout-as-a-privacy-risk/\",\n    priority: 10,\n}\n/* harmony export (immutable) */ __webpack_exports__[\"metadata\"] = metadata;\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = guid;\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = getStackTrace;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__loggers_screen__ = __webpack_require__(0);\n\n\n//just a bunch of utility functions\n\nfunction guid() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n    });\n}\n\nvar myError = Error //Some sites override error... copy it off XXX: In general need a better approach to issues like this\nfunction getStackTrace(Error, error){\n    try{\n        error = error || new myError()\n        var stack = parseV8OrIE(error)\n        var index = stack.findIndex((frame)=>frame.fileName && frame.fileName.indexOf('http')!==-1)\n        return stack.slice(index)\n    } catch(err){\n        return null\n    }\n}\n\n//Taken from stacktrace.js\n//https://github.com/stacktracejs/stacktrace.js/blob/89214a1866da9eb9fb25054d64a65dea06e302dc/dist/stacktrace.js#L52\nvar CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+\\:\\d+|\\(native\\))/m;\nfunction parseV8OrIE(error) {\n    var filtered = error.stack.split('\\n').filter(function(line) {\n        return !!line.match(CHROME_IE_STACK_REGEXP);\n    }, this);\n\n    return filtered.map(function(line) {\n        if (line.indexOf('(eval ') > -1) {\n            // Throw away eval information until we implement stacktrace.js/stackframe#8\n            line = line.replace(/eval code/g, 'eval').replace(/(\\(eval at [^\\()]*)|(\\)\\,.*$)/g, '');\n        }\n        var tokens = line.replace(/^\\s+/, '').replace(/\\(eval code/g, '(').split(/\\s+/).slice(1);\n        var locationParts = extractLocation(tokens.pop());\n        var functionName = tokens.join(' ') || undefined;\n        var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n\n        return {\n            functionName: functionName,\n            fileName: fileName,\n            lineNumber: locationParts[1],\n            columnNumber: locationParts[2],\n            //source: line\n        };\n    }, this);\n}\nfunction extractLocation(urlLike) {\n    // Fail-fast but return locations like \"(native)\"\n    if (urlLike.indexOf(':') === -1) {\n        return [urlLike];\n    }\n\n    var regExp = /(.+?)(?:\\:(\\d+))?(?:\\:(\\d+))?$/;\n    var parts = regExp.exec(urlLike.replace(/[\\(\\)]/g, ''));\n    return [parts[1], parts[2] || undefined, parts[3] || undefined];\n}\n\n\n/***/ })\n/******/ ])[\"default\"];"

/***/ }),

/***/ 2:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = guid;
/* harmony export (immutable) */ __webpack_exports__["a"] = getStackTrace;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__loggers_screen__ = __webpack_require__(0);


//just a bunch of utility functions

function guid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
    });
}

var myError = Error //Some sites override error... copy it off XXX: In general need a better approach to issues like this
function getStackTrace(Error, error){
    try{
        error = error || new myError()
        var stack = parseV8OrIE(error)
        var index = stack.findIndex((frame)=>frame.fileName && frame.fileName.indexOf('http')!==-1)
        return stack.slice(index)
    } catch(err){
        return null
    }
}

//Taken from stacktrace.js
//https://github.com/stacktracejs/stacktrace.js/blob/89214a1866da9eb9fb25054d64a65dea06e302dc/dist/stacktrace.js#L52
var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+\:\d+|\(native\))/m;
function parseV8OrIE(error) {
    var filtered = error.stack.split('\n').filter(function(line) {
        return !!line.match(CHROME_IE_STACK_REGEXP);
    }, this);

    return filtered.map(function(line) {
        if (line.indexOf('(eval ') > -1) {
            // Throw away eval information until we implement stacktrace.js/stackframe#8
            line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^\()]*)|(\)\,.*$)/g, '');
        }
        var tokens = line.replace(/^\s+/, '').replace(/\(eval code/g, '(').split(/\s+/).slice(1);
        var locationParts = extractLocation(tokens.pop());
        var functionName = tokens.join(' ') || undefined;
        var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];

        return {
            functionName: functionName,
            fileName: fileName,
            lineNumber: locationParts[1],
            columnNumber: locationParts[2],
            //source: line
        };
    }, this);
}
function extractLocation(urlLike) {
    // Fail-fast but return locations like "(native)"
    if (urlLike.indexOf(':') === -1) {
        return [urlLike];
    }

    var regExp = /(.+?)(?:\:(\d+))?(?:\:(\d+))?$/;
    var parts = regExp.exec(urlLike.replace(/[\(\)]/g, ''));
    return [parts[1], parts[2] || undefined, parts[3] || undefined];
}


/***/ })

/******/ });